{
  "hash": "1e60adb867e231f358cae579bbb3c79d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Variable Storage & Data Structures\ndescription: 'The building blocks of data science in R\n\n  '\ncreative_commons: CC BY\n---\n\n\n\n\n\n\n:::obj\n\n**Learning objectives**\n \n - Assigning objects\n - Know basic object classes (logical, numeric, factor, character)  \n - Understand basic R data structures (vectors, lists, data.frames)\n - Know properties of R data structures and how to interact with them\n - Know how to spot and deal with missing values (`NA`)\n\n:::\n\n## Assignment\n\nR is an object oriented programming language, which means that it is oriented around objects which can be data (e.g., data.frames, vectors, lists) or code (e.g., functions). We've already been using assignment to create variables, or objects. In the previous lesson, we read in csv files and **assigned** them to a variable using the assignment operator, `<-` (RStudio shortcut: `Alt` + `-`). Avoid using `=` for assignment which will also work but cause confusion later ([here's a blog post on the history behind `<-`](https://colinfay.me/r-assignment/)). \n\nWhen assigning an object, avoid overly simplistic names (e.g., `x`, `y`), and rather, pick concise names that describes the object and improve code interpretability. Let's read in our groundwater level station data and *assign* it to the variable name `stations`.\n\n<aside>In R the only true rule about naming variables is we can't start a variable with a number or use special characters (i.e., +-!@#$%^*) </aside>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read the stations.csv file and assign it to an object \"stations\"\nstations <- read.csv(\"data/gwl/stations.csv\")\n```\n:::\n\n\n\n\nNotice that in the Global Environment pane, we have now have a \"Data\" object `stations`.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/rstudio_env_stations.png){width=80%}\n:::\n:::\n\n\n\n\nLet's look at what types of data (*classes*) these columns currently have. We can use some useful functions that help us explore data a bit more, as well as use RStudio to figure these things out. We'll talk more about functions later -- there's an entire [module on functions]() coming up.\n\nLet's look at `str()` or **structure** first. The same information can be displayed in RStudio by clicking the blue arrow in the Environment tab.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(stations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t43807 obs. of  15 variables:\n $ STN_ID     : int  51445 25067 25068 39833 25069 38479 35592 48699 20460 35590 ...\n $ SITE_CODE  : chr  \"320000N1140000W001\" \"325450N1171061W001\" \"325450N1171061W002\" \"325450N1171061W003\" ...\n $ SWN        : chr  \"\" \"19S02W05K003S\" \"19S02W05K004S\" \"19S02W05K005S\" ...\n $ WELL_NAME  : chr  \"Bay Ridge\" \"\" \"\" \"\" ...\n $ LATITUDE   : num  35.6 32.5 32.5 32.5 32.5 ...\n $ LONGITUDE  : num  -122 -117 -117 -117 -117 ...\n $ WLM_METHOD : chr  \"USGS quad\" \"Unknown\" \"Unknown\" \"Unknown\" ...\n $ WLM_ACC    : chr  \"Unknown\" \"Unknown\" \"Unknown\" \"Unknown\" ...\n $ BASIN_CODE : chr  \"\" \"9-033\" \"9-033\" \"9-033\" ...\n $ BASIN_NAME : chr  \"\" \"Coastal Plain Of San Diego\" \"Coastal Plain Of San Diego\" \"Coastal Plain Of San Diego\" ...\n $ COUNTY_NAME: chr  \"Monterey\" \"San Diego\" \"San Diego\" \"San Diego\" ...\n $ WELL_DEPTH : int  NA NA NA NA NA NA NA 280 NA NA ...\n $ WELL_USE   : chr  \"Residential\" \"Unknown\" \"Unknown\" \"Unknown\" ...\n $ WELL_TYPE  : chr  \"Part of a nested/multi-completion well\" \"Unknown\" \"Unknown\" \"Unknown\" ...\n $ WCR_NO     : chr  \"\" \"\" \"\" \"\" ...\n```\n\n\n:::\n:::\n\n::: {.cell preview='true'}\n::: {.cell-output-display}\n![](images/rstudio_env_stations_expand.png){width=80%}\n:::\n:::\n\n\n\n\n\nThis function `str()` tells us the structure of the data. It gives us:\n\n - the type of Data (`data.frame`)\n - the column names (the part after `$`) \n - the **data class** (`int`=integer, `num`=numeric, `chr`=character)\n - the number of rows in our dataset (or the length of the vector)\n - finally, the the first 5 values for that vector \n\n## Basic object classes\n\nEvery object in R has a `class` property, and each property defines what functions will work on it. Many bugs result from functions applied to the wrong object class, so it's important to know how to check the class of an object and figure out what functions can be applied to it. \n\nThere are more base object classes in R, like matrices and arrays, but in this course we will focus on vectors, and devote most of our attention to a special type of list called the `data.frame` or `tibble`.  \n\nLet's check the class of the objects we created above with the `class()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(stations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nWhat about for a single column? Or a value we assign to some text?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(stations$SITE_CODE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nriver_name <- \"Sacramento River\"\nclass(river_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\nAs expected, `stations` is a data.frame, `stations$SITE_CODE` is a vector of *character*, and `river_name` is a single value of class *character*. **Vectors** are objects where every entry in that object is the **same type of data**. Sometimes, these are called **atomic vectors** because each part of the vector is the same.\n\nThere are 4 major classes of atomic vectors, arranged below in order of complexity.  \n\n* **logical** (`TRUE`, `FALSE`)  \n* **numeric** (contains both integer and double, but we will only cover double)  \n* **factor** (categorical and ordinal variables)  \n* **character** (strings)  \n\nUse the `c()` (**concatenate or combine**) function to create vectors. Let's use `c()` to create each of these 4 vector classes for an imaginary data set of river reaches.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# logical: is the river dry at the time of measurement\ndry <- c(TRUE, FALSE, FALSE)\n\n# flow measured at each reach in cfs\nflow <- c(0, 57, 128)\n\n# month the measurement was taken\ndate <- factor(c(\"July\", \"January\", \"February\"), levels = month.name)\n\n# reach name\nreach <- c(\"Dry Creek\", \"Raging Waters\", \"Wild Rapids\")\n```\n:::\n\n\n\n\n\nEach vector above has **3 entries**, also called **elements**. We can check the class of each of these vectors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dry)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(flow)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(reach)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n### logical (boolean)\n\nLogical vectors (also called booleans) are the most simple type of atomic vectors, and can take one of three values: `TRUE`, `FALSE`, or `NA`. Logical vectors are output as the result of logical tests.\n\n<aside> There are many ways to query or use logical tests for data. In other languages like SQL, these are words like **AND**, **OR** **IN**. In R, we use **`&`** for AND, **`|`** for OR, and **`%in%`** for IN. For more on this see [Fig 5.1 in R4DS](https://r4ds.had.co.nz/transform.html#logical-operators). </aside>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Is the character string \"Merced River\" in the character vector \"reach\"?\n\"Merced River\" %in% reach\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Is the character string \"Raging Waters\" in the character vector \"reach\"?\n\"Raging Waters\" %in% reach\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n### numeric\n\nImagine you wanted to transform the numeric flow data you have from cubic feet per second (cfs) to gallons per minute (gpm). R is a \"vectorized\" language and allows transformations over an entire vector with relative ease.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert each element of \"flow\" from cfs to gpm by multiplying by 448.83\nflow_gpm <- flow * 448.83\n\n# print the result\nflow_gpm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     0.00 25583.31 57450.24\n```\n\n\n:::\n:::\n\n\n\n\n\n### factor\n\nIf our factor variable `month` was an ordinary character vector, it would not sort meaningfully.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndate_character <- c(\"July\", \"January\", \"February\")\nsort( date_character )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"February\" \"January\"  \"July\"    \n```\n\n\n:::\n:::\n\n\n\n\nThe above is out of order, but if we define the **levels** that these ordinal variables should follow, we can store the vector as a factor and get meaningful sorting behavior. R defaults to alphabetic order with character vectors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a factor by specifying the levels (order) of the variable\ndate <- factor(c(\"July\", \"January\", \"February\"), levels = month.name)\nsort(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] January  February July    \n12 Levels: January February March April May June July August ... December\n```\n\n\n:::\n:::\n\n\n\n\n### character (string)\n\nCharacter vectors can store arbitrary strings. There are many ways to work with strings from [basic string manipulation](https://r4ds.had.co.nz/strings.html), all the way to [natural language processing](https://www.tidytextmining.com/) that we don't have time to cover in this course, but you should know that they exist. \n\nCreate strings by enclosing them with quotation marks. It doesn't matter if you use single (') or double quotes (\"), just be sure to use the same quote style for a single character string!  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a character vector of length 1 using single quotes\nhello <- 'Why helloooo'\n\n# create a character vector of length 2 using double quotes\ninstructors <- c(\"Rich\", \"Ryan\")\n\n# paste the vectors together\npaste(hello, instructors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Why helloooo Rich\" \"Why helloooo Ryan\"\n```\n\n\n:::\n:::\n\n\n\n\nNotice that when we pasted together a vector of length 1 with a vector of length 2, we got an output character vector of length 2. This concept is called \"recycling\" (because the shorter length vector was used twice, or recycled) and will come back later in this module.  \n\n\n:::challenge\n\n<font color=\"#009E73\">**Challenge 1**</font> \n\n1. Create an character vector called `meals` and assign it a string with what you plan to have for for breakfast, lunch, and dinner today.  \n2. Create a numeric vector called `cost` with the approximate cost in dollars of each meal.  \n3. Calculate the cost each meal if you ate that and only that for 365 days a year (Hint: multiply `cost` by 365, then take the `sum()`).  \n4. **Bonus**: Paste together a string that announces this cost.  \n\n:::\n\n<br>\n\n<details>\n  <summary class=\"challenge-ans-title\"><font color=\"#0072B2\">**Click for Answers!**</font></summary>\n  <div class=\"challenge-ans-body\">\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a string of three meals\nmeals <- c(\"eggs, toast and coffee\", \"pizza\", \"tacos and salad\")\n\n# cost of each meal in dollars\ncost <- c(2.25, 5.50, 8.95)\n\n# annual cost\nannual_cost <- cost * 365\nsum(annual_cost)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6095.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# bonus\npaste(\"Three meals a day costs\", sum(annual_cost), \"per year.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Three meals a day costs 6095.5 per year.\"\n```\n\n\n:::\n:::\n\n\n\n\n  </div>\n</details>\n\n\n\n## Basic data structures\n\nVectors are the building blocks of more useful data structures, especially the `data.frame` and `tibble` that will be the focus of subsequent modules. \n\n### vector\n\nAbove, we covered atomic vectors, which have one and only one class (logical, factor, numeric, character). All vectors have a property of `length` greater than 1.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(reach)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(flow)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n\n### list\n\nA special type of non-atomic vector called the `list` can contain many different types of data. Lists can contain any types of data structures, even other lists!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(dry, reach, flow, \"a random string\")\nlength(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can access list elements with double bracket notation `[[` and the index (think row number) of the element we want. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# access first element of the list\nl[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# access second element\nl[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Dry Creek\"     \"Raging Waters\" \"Wild Rapids\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n# access third element\nl[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   0  57 128\n```\n\n\n:::\n:::\n\n\n\n\nWe can also name a list, and then access list elements with double-bracket notation and **name** instead of index, like so: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(l) <- c(\"dry\", \"reach\", \"flow\", \"string\")\nl[[\"dry\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### data.frame and tibble\n\nThe `data.frame` is perhaps the most common form of data you will encounter in R, and the focus of most of the rest of the modules in the course. The data frame is a set of named vectors arranged as columns all of a common length, typically atomic vectors, but they can host general vectors or lists as well^[List-columns are a special type of data that we will cover elsewhere.]. \n\nLet's use the vectors we created earlier to make a `data.frame` called `riv`.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nriv <- data.frame(reach, date, dry, flow)\n\nriv\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"reach\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"date\"],\"name\":[2],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"dry\"],\"name\":[3],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"flow\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Dry Creek\",\"2\":\"July\",\"3\":\"TRUE\",\"4\":\"0\"},{\"1\":\"Raging Waters\",\"2\":\"January\",\"3\":\"FALSE\",\"4\":\"57\"},{\"1\":\"Wild Rapids\",\"2\":\"February\",\"3\":\"FALSE\",\"4\":\"128\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\nWe can access any column from the data frame as a vector using the `$` notation. In RStudio, typing `$` also brings up an auto-complete, and we can see all of the columns in the `data.frame`.\n\n<aside> \n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Use $ to access columns](images/R_dollar_sign_example.png){width=80%}\n:::\n:::\n\n\n\n</aside>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nriv$reach\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Dry Creek\"     \"Raging Waters\" \"Wild Rapids\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nriv$flow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   0  57 128\n```\n\n\n:::\n:::\n\n\n\n\nWe can also use `$` to remove a column if we assign an existing column to a value of `NULL`, or add a **new column** by entering a new column name not already present, and assigning it a value.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove the \"Reach\" column\nriv$reach <- NULL\nriv\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"date\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"dry\"],\"name\":[2],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"flow\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"July\",\"2\":\"TRUE\",\"3\":\"0\"},{\"1\":\"January\",\"2\":\"FALSE\",\"3\":\"57\"},{\"1\":\"February\",\"2\":\"FALSE\",\"3\":\"128\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add the reach column back, but called \"reach_name\" this time\nriv$reach_name <- reach\nriv\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"date\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"dry\"],\"name\":[2],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"flow\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"reach_name\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"July\",\"2\":\"TRUE\",\"3\":\"0\",\"4\":\"Dry Creek\"},{\"1\":\"January\",\"2\":\"FALSE\",\"3\":\"57\",\"4\":\"Raging Waters\"},{\"1\":\"February\",\"2\":\"FALSE\",\"3\":\"128\",\"4\":\"Wild Rapids\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\nWhen we assign a vector to a `data.frame` with length less than the total number of rows of the `data.frame`, R will try to \"recycle\" the vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add a vector \"tech\" for the \"field technician\" to be recycled\nriv$tech <- c(\"Rich\", \"Ryan\")\n```\n:::\n\n\n\n\nUh oh! This won't work because the length of the vector we attempted to add (2) to the `data.frame` isn't equal to, or a multiple of, the number of rows (3).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(riv) # total rows is 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(riv) == length(c(\"Rich\", \"Ryan\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nHowever, if we add a vector to the `data.frame` with length 1 (which is a multiple of 3):  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nriv$tech <- \"Rich\"\nriv\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"date\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"dry\"],\"name\":[2],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"flow\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"reach_name\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"tech\"],\"name\":[5],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"July\",\"2\":\"TRUE\",\"3\":\"0\",\"4\":\"Dry Creek\",\"5\":\"Rich\"},{\"1\":\"January\",\"2\":\"FALSE\",\"3\":\"57\",\"4\":\"Raging Waters\",\"5\":\"Rich\"},{\"1\":\"February\",\"2\":\"FALSE\",\"3\":\"128\",\"4\":\"Wild Rapids\",\"5\":\"Rich\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\nR **recycles** the string \"Rich\", repeating it 3 times. This is convenient, but can also lead to silent bugs, so we advise using the `tibble` instead of the `data.frame`.\n\nThe `tibble` is a modern `data.frame` with stricter recycling rules, R-friendly print behavior (prints only the first 10 rows and shows column types), and a [few more features](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html) that make them more predictable and less likely to lead to bugs.\n\nTo use `tibble` data types, we need to read our data with one of the [`tidyverse`](https://www.tidyverse.org/) packages,[`readr`](https://readr.tidyverse.org/). \nWhen we read `stations` with `read_csv()` it reads it in as a tibble, which we can verify with `class(stations)`. We can always convert `stations` back to just a data.frame and print it to console by running `data.frame(stations)`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nstations <- read_csv(\"data/gwl/stations.csv\")\nstations_df <- data.frame(stations)\nclass(stations_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n`tibble`s are essentially spreadsheets in R, flat, 2D rectangular data made of rows and columns. We can check the number of rows and columns in a `tibble`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(stations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 43807    15\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(stations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 43807\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(stations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n\nA `tibble` combines lists into columns, so its length is the same as its number of columns.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(stations) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n\n\n:::challenge\n\n<font color=\"#009E73\">**Challenge 2**</font> \n\n1. Extract the \"LATITUDE\" column from `stations`, assign it to a variable called `lat`, and calculate the mean latitude.  \n2. Assign a column to `riv` called \"depth\" with values 1, 2, 3. \n3. Assign another column called \"width\" with values 10, 10, 10. Take advantage of recycling when creating the \"width\" column.  \n4. Assign a new variable called \"area\" to `riv` which is the product of \"depth\" and \"width\" (Hint: `riv$depth * riv$width`).  \n\n:::\n\n<br>\n\n<details>\n  <summary class=\"challenge-ans-title\"><font color=\"#0072B2\">**Click for Answers!**</font></summary>\n  <div class=\"challenge-ans-body\">\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract LATITUDE and calculate the mean value\nlat <- stations$LATITUDE\nmean(lat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35.95708\n```\n\n\n:::\n\n```{.r .cell-code}\n# add depth and width to riv\nriv$depth <- c(1, 2, 3)\nriv$width <- 10 # this vector of length 1 is recycled \n\n# calculate area and add it to riv\nriv$area <- riv$depth * riv$width\n```\n:::\n\n\n\n\n  </div>\n</details>\n\n\n## A note on `NA`\n\n`NA` has a special meaning in R and designates a missing value. Operations on a vector with missing values cannot return a value unless we explicitly tell R to ignore these missing values.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- c(2, NA, 4)\nmean(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(z, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(z, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\n\n*Lesson adapted from [R for Data Science](https://r4ds.had.co.nz/)*.\n\n\n<br>  \n\n\n",
    "supporting": [
      "m_data_structures_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}