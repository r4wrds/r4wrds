{
  "hash": "906fc08799e1d6dd6cb5391751fe7177",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Version Control with `git`\"\ndescription: 'A time machine you can share...\n\n  '\ncreative_commons: CC BY\n---\n\n\n\n\n\n\n::: {.obj}\n**Learning objectives**\n\n-   Understand and use basic `git` commands for version control\n-   Develop a mindset and approach to set up and manage a version controlled project\n-   Identify best practices for using `git` collaboratively\n:::\n\nThis lesson assumes you have:\n\n-   Set up a Github Account\n-   Installed `git` on your computer locally\n\n## The case for version control\n\nAs water data scientists, we will work independently and with others on documents, data, and code that change over time. **Version control** is a framework and process to keep track of changes made to a document, data, or code with the added bonus that **you can revert to any previous change or point in time** *and* **you can work in parallel with multiple people on the same material.** In this module, we will practice version control with `git`, which is perhaps the most common version control system available today.\n\nThe important difference between using a tool like `git` and Github versus cloud-based services (e.g., Dropbox, Google Docs) which are in a way, version control systems, is the ability to **control** exactly what changes and/or files get \"versioned\". These versions are snapshots of your work with unique identifiers along with a short `commit` message, which allows us to restore these changes at any point in time. Thus, `git` offers much finer control over specific changes by specific users; this makes version control a very powerful tool (as well as a computer lifesaver when things go awry!).\n\nWhat is the difference between `git` and Github?\n\n-   **`git`** is a version control program that is installed on your computer with associated commands we use to interact with version controlled files.\\\n-   **Github** is a website that interfaces with `git` and allows us to store/access/share our files as *repositories*[^1].\n\n[^1]: Github is not the only site that integrates with `git` to provide cloud-based version control. Other notable examples include [Gitlab](https://about.gitlab.com/) and [Bitbucket](https://bitbucket.org/). In this module, we will focus on Github, although the underlying `git` commands you will learn are extensible to other `git`-based repositories.  \n\nThere is a rich and complex set of tools and functionality with `git` and Github, but in this module, we'll focus on the basics and link to more material.\n\n### Using version control\n\nSome folks may just use version control as another way to backup their work[^2], but version control really shines when working on a collaborative project. For example, many are familiar with the situation below:\n\n[^2]:  [Git xkcd](https://xkcd.com/1597/)\n\n![Figure from <http://www.phdcomics.com/comics/archive/phd101212s.gif>](images/final_doc_phd_comics.png){.external width=\"80%\"}\n\n<br>\n\nThe comic above shows a single thesis document, but really the situation isn't any different than a big data analysis project. A common series of steps that are generally taken by multiple people, may include:\n\n1.  Download/gather data\n2.  Clean/transform data\n3.  Analyze and visualize data\n4.  Produce a front facing product or report\n\nMany of these tasks (or subtasks) may overlap or depends on one another. Complex collaborative projects require forethought in how to set things up so everyone can seamlessly stitch their contribution into the overall fabric of a project without holding up the process for other team members.\n\n<aside>\n\nWith version control, if changes you make break things, it's easy to revert or get back to an earlier working version using the [commit timeline](https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History), because we have access to the history of our changes.\n\n</aside>\n\n::: {.challenge}\n<font color=\"#009E73\">**Pause and Discuss!**</font>\n\n<p style=\"line-height: 1.5em;\">\n\nIf you had 10 people to work on a big project with steps outlined above, how would you approach it? How would you break out these pieces or subtasks? How would you track progress?\n\n</p>\n:::\n\n<br>\n\nThis module will cover version control with **`git`**, including the basic commands, but it's important to remember:\n\n> **Understanding and learning how to approach, setup, and implement collaborative projects with version control are just as important as learning `git` commands**\n\nThus, successful version control is not just about effectively using tools like `git`, but also developing skills to organize projects, collaborate with others, and implement version control so it's useful (not just another way to back things up...see below).\n\n![*Learn to leverage the power of git for things other than just a backup!* (Figure from <https://xkcd.com/1597/>)](images/xkcd_using_git.png){.external width=\"60%\"}\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n<br>\n\n## Learning `git` through a project\n\nSometimes the best way to learn is to walk through a real-world example. Let's walk through a simplified example of a common set of tasks a team may face using `R` and learning `git` along the way.\n\nLet's imagine we have a team, <font color=\"#5f3dc4\">**Jo**</font> and <font color=\"#2b8a3e\">**Mo**</font>. Each has a unique skill set, and each knows how to use `R` and `git`. The team is tasked with downloading and visualizing flow data for a specific river gage to provide status report updates on a monthly basis, which are used for various regulatory actions (i.e., how much water is available for diversion, how flows relate to period of record averages, etc). In this case, the *cloud* is Github where our <font color=\"#e67700\">**`main`**</font> repository lives. More on this in a moment. First we need to make sure everything is setup and installed before we begin our `git` project!\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![An example team and workflow.](images/team_and_task_v2.png){width=80%}\n:::\n:::\n\n\n\n\n\n\n### Setup `git` locally\n\nWe highly recommend Jenny Bryan & Jim Hester's [happygitwithr](https://happygitwithr.com) website because it covers everything (and more) that you may encounter when using `git` with R. In particular, please take a moment to check/update your `git` installation and configure Github. The following links will help with this:\n\n-   [**Install Git**](https://happygitwithr.com/install-git.html)\n-   [**Introduce yourself to Git**](https://happygitwithr.com/hello-git.html)\n\nThe {[`usethis`](https://usethis.r-lib.org/articles/articles/usethis-setup.html)} package is an excellent option to help you get things setup within `R`, like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(usethis)\n\n# use your actual git user name and email!\nuse_git_config(user.name = \"yoda\", user.email = \"yoda2021@example.org\")\n```\n:::\n\n\n\n\nRemember, we only need to do this once![^3]\n\n[^3]: If you ever need to edit your global/git profile, you can use a situation report, `usethis::git_sitrep()` to see what settings exist and how to diagnose problems.\n\n### Create a Repository\n\nThere are several ways to create repositories on Github and with RStudio[^4]. We recommend the [*Github first*](https://happygitwithr.com/new-github-first.html#new-github-first) option as it's easiest to intialize and manage.\n\n[^4]:  [see this excellent overview of the various ways to create/link an RStudio project with a Github repository](https://happygitwithr.com/usage-intro.html)\n\nTo begin, go to Github.com and login. From there, let's create a new repository!\n\n::: {.challenge}\n<font color=\"#009E73\">**Challenge**</font>\n\n<p style=\"line-height: 1.5em;\">\n\nPlease take a moment and create a new repository on Github following the [happygitwithr.com instructions](https://happygitwithr.com/new-github-first.html#new-github-first).\n\n-   Name the repository `water-is-life`\n-   Check the **Add a README file** box at the bottom\n-   Make this a public repository\n\n</p>\n:::\n\n<details>\n\n<summary class=\"challenge-ans-title\"><font color=\"#0072B2\">**Click for Answers!**</font></summary>\n\n::: {.challenge-ans-body}\nHopefully you see something like this before you click the green **Create Repository** button.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/newrepo.png){width=90%}\n:::\n:::\n\n\n\n\nAnd then afterwards, a screen like this:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/newrepo2.png){width=90%}\n:::\n:::\n\n\n\n:::\n\n</details>\n\nThe last piece to this is getting this repository which is currently in the \"cloud\" to a local copy on your computer. This is called **`cloning`**. To clone the repository to your computer, we need to do the following:\n\n-   Copy the repository address. Make sure you've clicked **HTTPS** and the link in the box starts with `https://`. Copy that link to your clipboard.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/clone_repo.png){width=60%}\n:::\n:::\n\n\n\n\n-   Now open RStudio and navigate to **File \\> New Project \\> Version Control \\> Git**\n-   In the ***Repository URL*** box, paste the link in, and hit **`Tab`**. The ***Project directory Name*** should automagically fill with the name of the repository. Go ahead and put this where you want it to live locally[^5] and hit **Create Project**. *Open in new session* is optional, but allows you to keep existing projects open.\n\n[^5]: It's a good idea to store all your github repositories in one place (e.g., `~/Documents/Github`). We recommend to avoid nesting `git`/RStudio projects inside other `git`/RStudio projects--this can create confusion and make it difficult to properly version control different projects. Each project should have its own repository (e.g., `~/Documents/Github/project_01`, `~/Documents/Github/project_02`).\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/newRgit_proj.png){width=60%}\n:::\n:::\n\n\n\n\nGreat! We should now have an RStudio project that is version controlled with `git`, and there is a local copy we can work with on our computer.\n\n### Collaborative Github Settings\n\nSince we are working on a collaborative project, we need to make sure our collaborators have access to make changes to our repository. So, if <font color=\"#5f3dc4\">**Jo**</font> created the repository, they would need to add fellow collaborators to the repository. Let's do that now:\n\n-   Go to Github.com and login\n-   Navigate to your repository `water-is-life`\n-   Click on the **`Settings`** tab in the upper right corner  \n\n\n<aside>\n\nYou can view and clone (copy) any public Github repository. However, you can only commit changes if you are the owner, or have been added as a collaborator (more on this later).\n\n</aside>\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Click on the Settings tab in the upper right corner to add collaborators.](images/git_settings.png){width=50%}\n:::\n:::\n\n\n\n\n-   Click on **`Manage Access`** on the side bar on the left (you may need to enter your password or authentication again)\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Then click on Manage Access.](images/git_manage_access.png){width=50%}\n:::\n:::\n\n\n\n\n-   Click on **`Invite Collaborator`** and enter the username or email you want to add!\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Invite collaborators by email or username!](images/git_invite_collaborators.png){width=221}\n:::\n:::\n\n\n\n\n### Branches & Conflicts\n\nOften when teaching `git`, we start with the basic commands. However, it's important to consider one of the more powerful parts of using `git` is the ability to use **branches**. Branches, or branching, in `git`, is a way for multiple folks to work on the same repository independently, and a standardized way to integrate those changes back into the repository. Every repository typically starts with one single **`main`** branch. This is like the trunk of the tree, or the main train track. We can create additional branches off of this track, and if we want to merge them back in to make them available for our collaborators, we use something called a **pull request**. This is essentially a way to double check if there will be any conflicts between the work in the branch and the work in the **`main`** branch[^6], and it also provides a way to document and review any changes. If a pull request does not create merge conflicts (don't worry about this now, we will cover it later) and if a collaborator on the repository *approves* the pull request, then the branch is \"pulled\" (or **merged**) into the `main` branch, and then typically deleted (since the branch has served its purpose, and the changes in it are now reflected in the `main` branch).  \n\n[^6]: In more complex workflows, we can pull branches into other branches before pulling them into the `main` branch. In the module, we will use more simplified examples, but just remember that there are many other ways to branch and merge.\n\n<aside>\n\nEven if you are the only person working in a repo, it's a good habit to use branches because if you realize the branch/work you are doing is a dead end, you can always delete a branch and return to the **`main`** branch to pick things up where you last left off.\n\n</aside>\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Example of multiple branches in a project splitting off the main branch](images/commit_branch_tracks.png){width=783}\n:::\n:::\n\n\n\n\n### Create a branch\n\nIn our example we want to make sure we keep our <font color=\"#e67700\">**`main`**</font> branch clean and up-to-date with changes we are happy with...all other work will go through a `branch`, *pull request*, **review**, and **`merge`** process to minimize conflicts or duplication of work.\n\n<font color=\"#5f3dc4\">**Jo**</font> is a wizard at grabbing the data we want to work with and saving it in an organized way. She's cloned the repository to her computer, and the first thing she wants to do is create a fresh branch to work off of, so her changes can be reviewed before being `merged` into the <font color=\"#e67700\">**`main`**</font> branch.\n\nWe can create a branch in RStudio in one of two ways:\n\n-   `Tools > Terminal > New Terminal` and look for the Terminal tab in RStudio. Click on it, and at the prompt, type:&nbsp;  **`git checkout -b BRANCH_NAME`**.\n-   Using the **`Git`** tab in RStudio and clicking on the **`New Branch`** button, type in the branch name, make sure the Remote is set to `origin` and click **`Create`**!\n\nLet's create a new branch called `jo_download_data`. Ideally, each team member will do the same, and each of these branches comes from the <font color=\"#e67700\">**`main`**</font> branch, which is the main trunk or \"clean\" version of the project.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/new_branch_1.png){width=354 height=70%}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![<font color=\"#5f3dc4\">**Jo**</font> creates a new branch from <font color=\"#e67700\">**`main`**</font> to write a data download script in `R`.](images/jo_data_gather_branch.png){width=693 height=80%}\n:::\n:::\n\n\n\n\n### Download Data: `add`, `commit`, `push`\n\nJo's task is to download the data. Because this is a task that will need to happen regularly, she writes a function to download the specific river discharge data to an organized set of folders. She runs the function to get the most recent data, and saves it locally *on her version of the repository!*\n\nAs she works, the general process she follows is:\n\n1.  **`add`**: Do some work, add some files, scripts, etc. To version control these changes, we need to stage or `add` that work so it can be *versioned* by `git`. We do this with `git add <my_file>` or check the **`Staged`** buttons in the RStudio `git` panel.\n\n2.  **`commit`**: Add a `commit` message that is succinct but descriptive (i.e., `added water data files`). These are the messages you'll be able to go back to if you want to travel back in time and see a different version of something...so be kind to your future self and add something helpful.\n\n3. **`push`**: Finally, when we're ready to send locally commited changes up the cloud, we `push` this up to the Github `remote` cloud repository!\n\nRemember, you can commit as frequently as you like, and push at the end of the day, or push every time you commit. The timestamp identifier is added with a commit message, not with the push.\n\n::: {.challenge}\n<font color=\"#009E73\">**You Try!**</font>\n\n<p style=\"line-height: 1.5em;\">\n\nTake the following function and:\n\n-   Make a new folder in your project called `code`, save as a script called `01_download_data.R`\n-   `stage` it (either through the Git tab, or via `git add`),\n-   `commit` (add a message!),\n-   `push` to the `jo_download_data` branch\n\n</p>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fs)\nlibrary(dataRetrieval)\nlibrary(readr)\nlibrary(glue)\n\n# make a function to download data, defaults to current date for end\n\n# function: dates as \"YYYY-MM-DD\"\nget_daily_flow <- function(gage_no){\n\n  # create folder to save data\n  fs::dir_create(\"data_raw\")\n\n  # set parameters to download data\n  siteNo <- gage_no # The USGS gage number\n  pCode <- \"00060\" # 00060 is discharge parameter code\n\n  # get NWIS daily data: CURRENT YEAR\n  dat <- readNWISdv(siteNumbers = siteNo,\n                    parameterCd = pCode)\n  # add water year\n  dat <- addWaterYear(dat)\n  # rename the columns\n  dat <- renameNWISColumns(dat)\n\n  # save out\n  write_csv(dat,\n            file =\n              glue(\"data_raw/nfa_updated_{Sys.Date()}.csv\"))\n}\n\n# RUN with:\n#siteNo <- \"11427000\"# NF American River\n# get_daily_flow(siteNo)\n```\n:::\n\n\n\n:::\n\n<details>\n\n<summary class=\"challenge-ans-title\"><font color=\"#0072B2\">**Answers!**</font></summary>\n\n::: {.challenge-ans-body}\nOnce we've made our script and saved it in the `code` folder, we should see something like this in our **`Git`** tab... notice the change when the box is checked.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_add-1.png){width=49%}\n:::\n\n::: {.cell-output-display}\n![](images/git_add-2.png){width=49%}\n:::\n:::\n\n\n\n\nNext we want to **`commit`** and add a message. Note when we first click the `Commit` button, we'll see this screen:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_staged_1.png){width=1001}\n:::\n:::\n\n\n\n\nWhen we enter a `commit` message and click `Commit`, we'll end up with this, which tells us our commit worked...but it's still only *local*! Note we'll have a message saying our branch is\n\n> *`ahead of origin/jo_download_data by 1 commit.`*\n\nThat's ok, it just means we still need to **`push`** our changes up to the remote branch.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_commit_commit.png){width=697}\n:::\n:::\n\n\n\n\nThe final step is to **`push`** our changes up to the cloud. Click **`Push`** and you should get a message back like this. This means things worked...a final check would be go to Github and make sure the file is online!\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_push_return.png){width=703}\n:::\n:::\n\n\n\n:::\n\n</details>\n\n<aside>\n\nThink of every commit you make as a train station. The more commits you make (and the more descriptive they are) the easier it will be to get around...particularly because your train can travel *back in time*!\n\n</aside>\n\n### Pull Requests\n\nThe next step in this `version control` odyssey is to get <font color=\"#5f3dc4\">**Jo's**</font> work from the `jo_download_data` branch into the <font color=\"#e67700\">**`main`**</font> branch. Here we use a ***Pull Request***. This is a way to review the changes, check for any conflicts (if for instance, folks were working on the same file), and then **Merge** these changes into the <font color=\"#e67700\">**`main`**</font> branch. Then we can delete the `jo_download_data` branch, create another one to work on the next task, and so on.\n\nHere's what we might see on Github if we visited our `water-is-life` repository after we pushed our changes up. First, we will hopefully see an option to make a pull request because Github recognizes there are changes from another branch that aren't in the `main` branch. We want to click the **Compare and pull request** button.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_pr1.png){width=915}\n:::\n:::\n\n\n\n\nNext we have an option to add some additional descriptions, comments, about what this pull request (PR) is doing, and why. We can tag a reviewer (collaborator on the Github repo), and add labels, milestones, etc. These are all helpful for keeping track of what's done and what's not.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_pr2.png){width=1250}\n:::\n:::\n\n\n\n\nAfter we click the green **Create pull request** button, we should see something that looks like the following. **Important**! We ideally will see a green checkmark with a message \"**This branch has no conflicts with the base branch**, which means, our **`main`** branch can easily merge this new work in!\n\n<aside>\n\n`merge conflicts` are not something to be worried about, they happen, and there are a number of ways to resolve them. A good resource and walk through using [Github is here](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-on-github), or with [command line here](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-using-the-command-line).\n\n</aside>\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_pr3.png){width=949}\n:::\n:::\n\n\n\n\n<aside>\n\n**Exiting `vim`**: if you end up in a text editor and aren't sure how to exit, you may be in `vim`. It is the default editor for many systems and programs. To exit without saving changes, hit **`Esc`**, then type **`:q!`** and hit **`Enter`**. To save changes, hit **`Esc`** and then type **`:wq`** and hit **`Enter`**.\n\n</aside>\n\n<br>\n\nGo ahead and click **Merge pull request**, and wait until you see a screen shortly after that says the **Pull request was successfully merged and closed**!\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/git_pr4.png){width=936}\n:::\n:::\n\n\n\n\n<br> \n\n### `fetch` and `pull`\n\nNow that <font color=\"#5f3dc4\">**Jo**</font> has completed the first part of the team task, we want to move to the second task, which is cleaning the data. Thankfully <font color=\"#2b8a3e\">**Mo**</font> is great at data visualization, and has a script that will clean up the code and visualize it for us. But first, <font color=\"#2b8a3e\">**Mo**</font> needs to `pull` the changes that <font color=\"#5f3dc4\">**Jo**</font> just merged into the <font color=\"#e67700\">**`main`**</font> repository. There are two approaches to this. One is to use a `git fetch`, the other is a `git pull`. The main difference between the two:\n\n-   **`fetch`**: The safe version, because it downloads any remote content from the repository, but *does not update your local repository state*. It just keeps a copy of the remote content, leaving any current work intact. To fully integrate the new content, we need to follow a `fetch` by a `merge`.\n-   **`pull`**: This downloads the remote content and then immediately `merges` the content with your local state, but if you have pending work, this will create something called a **merge conflict**, but not to worry, these can be fixed![^7].\n\n[^7]: <https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-on-github>\n\n<font color=\"#2b8a3e\">**Mo**</font> needs to **`pull`** changes in to his branch from <font color=\"#e67700\">**`main`**</font> and proceed with the task. Here we assume <font color=\"#5f3dc4\">**Jo**</font> has already completed work on her branch to download, clean, and transform the data.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/gather_clean_data_together_3b.png){width=1146}\n:::\n:::\n\n\n\n\n::: {.challenge}\n<font color=\"#009E73\">**You Try!**</font>\n\n<p style=\"line-height: 1.5em;\">\n\nTake the following code from <font color=\"#2b8a3e\">**Mo**</font> and:\n\n-   `pull` changes into the repository so everything is up-to-date!  \n-   create a unique branch: `mo_cleanviz`  \n-   save [**this code**](https://raw.githubusercontent.com/ryanpeek/water-is-life/main/code/02_clean_visualize.R) to a new script at `code/02_clean_visualize.R`\n-   `stage` it (either through the Git tab, or via `git add`),\n-   `commit` (add a message!),\n-   `push` to <font color=\"#2b8a3e\">**Mo's**</font> branch\n-   Finish by adding a **Pull Request** and merging back to <font color=\"#e67700\">**`main`**</font>!\n\n</p>\n:::\n\n<details>\n\n<summary class=\"challenge-ans-title\"><font color=\"#0072B2\">**Answers!**</font></summary>\n\n::: {.challenge-ans-body}\nNow we have a `commit` history that might look something like this.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/gather_clean_data_together_5b.png){width=1146}\n:::\n:::\n\n\n\n\nWhat is one explanation for commit **4**? We also have a project that is very easy to re-run and update, and it can be updated or integrated into a parameterized [Rmarkdown report](https://raw.githubusercontent.com/ryanpeek/water-is-life/main/summary_report.Rmd) which could be shared and updated easily.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/figure_flow_ribbon_wy_facet.png){width=1100}\n:::\n:::\n\n\n\n:::\n\n</details>\n\n<br>\n\n## Closing the loop\n\nWe've reviewed how to create branches, add and revise files, and then commit and push these changes to a shared repository for collaborative projects. Importantly, it's best practice to always `pull`/`fetch` at the beginning of each work session so you have the most-up-to-date changes. And if something needs to be fixed, you can always pull a specific branch and make a change and pull request for that branch before pull requesting and merging back to the `main`.\n\n<aside>\n\nFor example, if <font color=\"#5f3dc4\">**Jo**</font> needed to make a quick fix to some data analysis, she could pull <font color=\"#2b8a3e\">**Mo's**</font> branch, make a fix (commit **4**), and merge that back into the same branch before he finalizes the analysis and merges back to the <font color=\"#e67700\">**`main`**</font> branch.\n\n</aside>\n\n\n\n\n::: {.cell preview='true'}\n::: {.cell-output-display}\n![](images/gather_clean_data_together_6.png){width=1354}\n:::\n:::\n\n\n\n\nThis is a simplified workflow, but it is very powerful. There are additional options within this workflow, like reverting to previous versions, pruning branches or `git` history, and more, but the core steps to successfully using version control rely on the material covered above, and practice!\n\n<br> \n\n## Additional Git Details\n\nAlthough there are many more details important to learning version control, many come with more practice and expertise. However, a few important tidbits:\n\n-   When working on Github, there are options for `private` and `public` repositories. `private` repos are only visible to you and any collaborators you've added to your repo. Certain accounts permit unlimited `private` repos.\n-   `.gitignore`: We can access or create this file with the `usethis::edit_git_ignore()` function. Any file extension or specific file we include in our `.gitignore` file will mean `git` ignores it. This is helpful for hidden files or temporary files that may change a lot (i.e., `*.html`) but aren't necessary to version contol. You can even ignore entire directories or large files ( \\>= 100MB). Github is designed to version control scripts, not large amounts of data.  \n-   Additionally you can use the **`usethis::git_vaccinate()`** function to ensure there are no issues or secure files that may get accidentally added to your version control repository.\n-   Large files...Github is great, but less ideal for large files. Github will complain with any file over about \\~50MB, and anything greater than 100MB requires [`git-lfs`](https://git-lfs.github.com) (large file sizes), but it is still unwieldy. See [this article for suggestions and options](https://docs.github.com/en/github/managing-large-files/collaboration-with-git-large-file-storage).\n\n<br> \n\n## Resources & Tutorials\n\n-   <https://swcarpentry.github.io/git-novice/>\n-   <https://learngitbranching.js.org>\n-   [`R` for excel with github](https://rstudio-conf-2020.github.io/r-for-excel/github.html)\n-   [\"Excuse me do you have a moment to talk version control?\" by Jenny Bryan](https://peerj.com/preprints/3159/)\n-   [Github for project management](https://openscapes.github.io/series/github-issues.html)\n\n<br>\n",
    "supporting": [
      "m_version_control_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}